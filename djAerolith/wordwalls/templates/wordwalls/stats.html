{% extends "base.html" %}
{% load i18n %}
{% block ss %}
    <link href="/static/css/wordwalls/wordwallsCreateTable.css" rel="stylesheet">
    <link href="/static/css/aerolith/bootstrap-datepicker.css" rel="stylesheet">
{% endblock %}
{% block title %}{% trans "Wordwalls - select list" %}{% endblock %}

{% block content %}
<script src="/static/lib/bootstrap/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js"></script>
<!-- Add date adapter for Chart.js time scale -->
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<!-- Add regression.js for trend line -->
<script src="https://cdn.jsdelivr.net/npm/regression@2.0.1/dist/regression.min.js"></script>
<script src="/static/lib/bootstrap-datepicker.js"></script>

<div class="container">

    <div class="row">

        <div class="col-md-6">

            <p>

                Lexicon:<br>
                <select class="form-control" id="lexicon">
                  <option value="24">NWL23</option>
                  <option value="25">CSW24</option>
                  <option value="23">FRA24</option>
                  <option value="17">Deutsch</option>
                  <option value="26">OSPS50</option>
                  <option value="10">FISE2</option>
                </select>

            </p>

            <p>

                Challenge:<br>
                <select class="form-control" id="challenge">
                  <option value="1">Today's 2's</option>
                  <option value="2">Today's 3's</option>
                  <option value="3">Today's 4's</option>
                  <option value="4">Today's 5's</option>
                  <option value="5">Today's 6's</option>
                  <option value="6">Today's 7's</option>
                  <option value="7">Today's 8's</option>
                  <option value="8">Today's 9's</option>
                  <option value="9">Today's 10's</option>
                  <option value="10">Today's 11's</option>
                  <option value="11">Today's 12's</option>
                  <option value="12">Today's 13's</option>
                  <option value="13">Today's 14's</option>
                  <option value="14">Today's 15's</option>
                  <option value="15">Week's Bingo Toughies</option>
                  <option value="16">Blank Bingos</option>
                  <option value="17">Bingo Marathon</option>
                  <option value="18">Common Words (short)</option>
                  <option value="19">Common Words (long)</option>
                  <option value="20">Word Builder (3-6)</option>
                  <option value="21">Word Builder (4-7)</option>
                  <option value="22">Word Builder (5-8)</option>
                </select>

            <p>

                Start Date:<br>
                <input data-provide="datepicker" id="start-date" class="form-control date-picker">

            </p>

            <p>

                End Date:<br>
                <input data-provide="datepicker" id="end-date" class="form-control date-picker">

            </p>

            </p>

            <button type="button" class="btn btn-primary" id="dropdown-button">Submit</button>

            </p>

    </div>



    <div class="col-md-6">

        <table class="table">
          <thead>
            <tr>
              <th></th>
              <th>Average</th>
              <th></th>
              <th></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">Time Remaining (seconds)</th>
              <td><span id="time"></span></td>
              <td><span id="time-low"></span></td>
              <td><span id="time-high"></span></td>
            </tr>
            <tr>
              <th scope="row">Score</th>
              <td><span id="scores"></span></td>
              <td><span id="scores-low"></span></td>
              <td><span id="scores-high"></span></td>
            </tr>
            <tr>
              <th scope="row">Combined Score</th>
              <td><span id="combined-scores"></span></td>
              <td><span id="combined-scores-low"></span></td>
              <td><span id="combined-scores-high"></span></td>
            </tr>
          </tbody>
        </table>

    </div>

</div>

<div id="chart-container" class="container mt-4">
    <div class="mb-3">
        <div id="regression-equation" class="text-muted small"></div>
        <div id="trend-message" class="text-muted small font-italic"></div>
    </div>
    <div class="chart-wrapper" style="position: relative; height: 500px; width: 100%;">
        <canvas id="combinedChart"></canvas>
    </div>
</div>

</p>

<img src="/static/img/aerolith/blue_spinner.gif" style="display: none; position: fixed; left: 600px; top: 100px;" class="ring-spinner">

<script>

$('.date-picker').datepicker({
    format: 'yyyy-mm-dd'
});

// These hold info for the charts
var scoresByDate = {};
var dateArray = [];
var timeRemainingByDate = {};
var maxTimeByDate = {};
var maxScoreByDate = {};
var combinedScoresByDate = {};
var originalDataByDate = {};

// Beta value for the combined score calculation
const BETA = 50;

// Defining the chart as global - destroy the chart should the user
// select another option to view
var combinedChartObj;

$( "#dropdown-button" ).click(function() {

    $( ".ring-spinner").show();
    $( "#dropdown-button").prop('disabled', true);

    // Properly destroy the chart to prevent memory leaks
    if (combinedChartObj) {
        try {
            combinedChartObj.destroy();
            combinedChartObj = null;
        } catch (e) {
            console.error("Error destroying chart:", e);
        }
    }    // Simply recreate the canvas
    // First remove all Chart.js generated elements
    const chartContainer = document.getElementById('chart-container');
    const chartContainerDiv = chartContainer.querySelector('div');

    // Clear everything except the regression info
    while (chartContainerDiv.firstChild) {
        chartContainerDiv.removeChild(chartContainerDiv.firstChild);
    }

    // Create a fresh canvas with larger dimensions
    const canvas = document.createElement('canvas');
    canvas.id = 'combinedChart';
    canvas.height = 400; // Taller canvas
    chartContainerDiv.appendChild(canvas);

    // Disable animations
    Chart.defaults.animation = false;

    // Reset our data objects
    scoresByDate = {};
    dateArray = [];
    timeRemainingByDate = {};
    maxTimeByDate = {};
    maxScoreByDate = {};
    combinedScoresByDate = {};
    originalDataByDate = {};

    // This is the info we want
    var lexicon = $('#lexicon').val()
    var challenge = $('#challenge').val()
    var startDate = $('#start-date').val()
    var endDate = $('#end-date').val()

    // Call the API, receive JSON
    $.ajax({
          method: "GET",
          data: {start_date: startDate, end_date: endDate},
          url: "/wordwalls/stats/api/" + lexicon + "/" + challenge + "/",
          dataType: 'json'
    })
        .done(function(msg) {

            // Parse the JSON for the info we want for the charts
            for (var i = 0; i < msg.length; i++) {
                var value = msg[i];
                var dateString = value.Date;
                var scoreShortened = (Number(value.Score) / Number(value.maxScore)) * 100;
                var timeScore = (Number(value.timeRemaining) / Number(value.maxTime)) * BETA;

                // Calculate the combined score
                var combinedScore = scoreShortened + timeScore;

                // Store all values by date - ensure we're storing as numeric strings for consistent parsing
                scoresByDate[value.Date] = scoreShortened.toFixed(2);
                timeRemainingByDate[value.Date] = Number(value.timeRemaining).toFixed(2);
                maxTimeByDate[value.Date] = Number(value.maxTime).toFixed(2);
                maxScoreByDate[value.Date] = Number(value.maxScore).toFixed(2);
                combinedScoresByDate[value.Date] = combinedScore.toFixed(2);

                // Store original data for tooltip
                originalDataByDate[value.Date] = {
                    score: value.Score,
                    maxScore: value.maxScore,
                    timeRemaining: value.timeRemaining,
                    maxTime: value.maxTime,
                    scorePercent: scoreShortened.toFixed(2),
                    timeBonus: timeScore.toFixed(2),
                    combinedScore: combinedScore.toFixed(2)
                };

                dateArray.push(value.Date);
            }

            // Call the charts function to generate the chart on the page
            createCombinedChart();
        });

function getAverage(array, idToUpdate) {
    var count = 0;
    var total = array.length;

    for (var i = 0; i < array.length; i++) {
        num = parseFloat(array[i]);
        count += num;
    }

    var avg = (count / total).toFixed(2);
    var avgString = avg.toString();

    if (avgString === 'NaN') {
        avgString = '0';
    }

    var averageElement = $('#' + idToUpdate);
    averageElement.html(avgString);
}

function formatRegression(equation) {
    const slope = equation[0];
    const intercept = equation[1];

    // Format slope to show score change per day
    // Multiply by milliseconds per day to get daily change
    const millisecondsPerDay = 24 * 60 * 60 * 1000;
    const slopePerDay = slope * millisecondsPerDay;

    let formattedSlopePerDay = slopePerDay.toFixed(4);
    // Remove trailing zeros and decimal point if necessary
    formattedSlopePerDay = parseFloat(formattedSlopePerDay).toString();

    // Format intercept - add + sign if positive
    let formattedIntercept = intercept.toFixed(2);
    formattedIntercept = parseFloat(formattedIntercept).toString();
    const interceptSign = intercept >= 0 ? '+' : '';

    // Return a more human-readable form showing change per day
    return `Score change per day: ${formattedSlopePerDay} points`;
}

// This function is no longer used as we calculate the regression directly in the chart setup
function calculateRegressionLine(dates, scores) {
    // This function is kept for reference but is no longer used
    return [];
}

function createCombinedChart() {
    $( ".ring-spinner").hide();
    $( "#dropdown-button").prop('disabled', false);

    // Info for chart axes - ensure date sorting works chronologically
    // Sort dates properly by converting to Date objects first
    dateArray.sort(function(a, b) {
        return new Date(a) - new Date(b);
    });
    var scoresSorted = [];
    var timeSorted = [];
    var combinedScoresSorted = [];
    var sortedDates = [];

    for (var i = 0; i < dateArray.length; i++) {
        var date = dateArray[i];
        // Ensure we're working with numeric values
        scoresSorted.push(scoresByDate[date]);
        timeSorted.push(timeRemainingByDate[date]);
        combinedScoresSorted.push(combinedScoresByDate[date]);
        sortedDates.push(date);
    }

    console.log("Data prepared for chart:", {
        dates: sortedDates,
        scores: combinedScoresSorted.map(parseFloat)
    });

    // Calculate averages
    getAverage(scoresSorted, 'scores');
    getAverage(timeSorted, 'time');
    getAverage(combinedScoresSorted, 'combined-scores');

    // Calculate min/max values for all scores
    if (combinedScoresSorted.length > 0) {
        // Combined scores
        const combinedScoresNumbers = combinedScoresSorted.map(parseFloat);
        const minCombined = Math.min(...combinedScoresNumbers).toFixed(2);
        const maxCombined = Math.max(...combinedScoresNumbers).toFixed(2);
        $('#combined-scores-low').text(minCombined);
        $('#combined-scores-high').text(maxCombined);

        // Regular scores
        const scoresNumbers = scoresSorted.map(parseFloat);
        const minScore = Math.min(...scoresNumbers).toFixed(2);
        const maxScore = Math.max(...scoresNumbers).toFixed(2);
        $('#scores-low').text(minScore);
        $('#scores-high').text(maxScore);

        // Time remaining
        const timeNumbers = timeSorted.map(parseFloat);
        const minTime = Math.min(...timeNumbers).toFixed(2);
        const maxTime = Math.max(...timeNumbers).toFixed(2);
        $('#time-low').text(minTime);
        $('#time-high').text(maxTime);
    }

    // Create a fresh canvas - larger size
    $('#combinedChart').remove();
    $('#chart-container').append('<canvas id="combinedChart"></canvas>');
    var canvas = document.getElementById("combinedChart");
    var ctx = canvas.getContext('2d');

    // Convert dates to JavaScript Date objects
    const dateObjects = sortedDates.map(dateStr => new Date(dateStr));

    // Variables for regression
    let slope = 0;
    let intercept = 0;
    let r2 = 0;
    let startDate, endDate;

    // Calculate regression if we have enough data
    if (combinedScoresSorted.length >= 2) {
        // Use day numbers instead of timestamps to avoid precision issues with large numbers
        // Get the earliest date as reference point (day 0)
        const earliestDate = new Date(Math.min(...dateObjects.map(d => d.getTime())));
        const latestDate = new Date(Math.max(...dateObjects.map(d => d.getTime())));

        // Check if we have a valid date range (at least 1 day difference)
        const hasDateRange = (latestDate - earliestDate) >= (24 * 60 * 60 * 1000);

        // Create data points as [days since earliest date, score]
        const points = [];

        // Only proceed with regression if we have a valid date range
        if (hasDateRange) {
            for (let i = 0; i < combinedScoresSorted.length; i++) {
                // Calculate days since earliest date (using integers instead of huge timestamps)
                const daysSinceStart = Math.round((dateObjects[i] - earliestDate) / (24 * 60 * 60 * 1000));
                const score = parseFloat(combinedScoresSorted[i]);
                points.push([daysSinceStart, score]);
            }

            console.log("Date range in days:", (latestDate - earliestDate) / (24 * 60 * 60 * 1000));
        } else {
            console.log("All data points are from the same day - can't calculate trend");
            // Add artificial points to create a horizontal line
            points.push([0, parseFloat(combinedScoresSorted[0])]);
            points.push([1, parseFloat(combinedScoresSorted[0])]);
        }

        console.log("Regression points (days):", points);

        // Calculate linear regression using days since start
        const result = regression.linear(points);
        // This is now slope in score points per day
        slope = result.equation[0];
        intercept = result.equation[1];
        r2 = result.r2;

        console.log("Regression result:", {
            equation: result.equation,
            r2: result.r2,
            string: result.string,
            slopePerDay: slope
        });

        // Find the date range for drawing the trend line
        startDate = new Date(Math.min(...dateObjects.map(d => d.getTime())));
        endDate = new Date(Math.max(...dateObjects.map(d => d.getTime())));

        // Store the slope directly as points per day (no need for milliseconds conversion)
        const millisecondsPerDay = 24 * 60 * 60 * 1000;
        const slopePerDay = slope; // Already in points per day

        // Format the regression equation - slope is already in points per day
        const formattedSlope = slope.toFixed(4);

        // Display regression info
        $('#regression-equation').html(`Score change per day: ${formattedSlope} points (R² = ${r2.toFixed(4)})`);

        // Show trend message
        let trendMessage = "";
        if (Math.abs(slope) < 0.1) {
            trendMessage = "Your performance is stable over time.";
        } else if (slope > 0) {
            trendMessage = "Your performance is improving over time.";
        } else {
            trendMessage = "Your performance is declining over time.";
        }
        $('#trend-message').text(trendMessage);
    } else {
        // Not enough data
        $('#regression-equation').html('Not enough data for trend analysis');
        $('#trend-message').text('');
    }    // Prepare the datasets array - only data points and connectors
    const datasets = [
        {
            type: 'scatter',
            label: 'Combined Score',
            data: combinedScoresSorted.map((score, index) => ({
                x: new Date(sortedDates[index]),
                y: parseFloat(score),
                originalDate: sortedDates[index]
            })),
            backgroundColor: 'rgba(75, 192, 192, 1)',
            borderColor: 'rgba(75, 192, 192, 1)',
            pointRadius: 3,
            pointHoverRadius: 8,
            pointBorderWidth: 1,
            pointHoverBorderWidth: 2,
            pointStyle: 'circle',
            order: 1
        }
    ];

    // Only add connection line if we have data points
    if (combinedScoresSorted.length > 0) {
        datasets.push({
            type: 'line',
            label: 'Data Points Connection',
            data: combinedScoresSorted.map((score, index) => ({
                x: new Date(sortedDates[index]),
                y: parseFloat(score)
            })),
            borderColor: 'rgba(75, 192, 192, 0.2)',
            borderWidth: 0.5,
            borderDash: [3, 3],
            pointRadius: 0,
            fill: false,
            tension: 0,
            order: 2  // Will be rendered below the scatter points
        });
    }
     // Simplest chart options possible
    // Turn off all animations globally
    Chart.defaults.animation = false;

    // Add a trend line directly to the Chart.js datasets
    if (combinedScoresSorted.length >= 2) {
        console.log("Adding trend line as a simple dataset");

        // Calculate days since start for both start and end points
        const earliestDate = new Date(Math.min(...dateObjects.map(d => d.getTime())));
        const startDays = 0; // Start at day 0
        const endDays = Math.round((endDate - earliestDate) / (24 * 60 * 60 * 1000));

        // Apply the regression formula: y = mx + b where x is days since start
        const startY = slope * startDays + intercept;
        const endY = slope * endDays + intercept;

        // Convert back to actual dates for the chart
        const startX = earliestDate.getTime();
        const endX = endDate.getTime();

        console.log("Regression line details:", {
            startDays, endDays,
            startDate: new Date(startX),
            endDate: new Date(endX),
            slope, intercept, // slope is now in score points per day
            startY, endY,
            slopePerDay: slope
        });

        // Add the trend line as a simple line dataset
        datasets.push({
            type: 'line',
            label: 'Trend Line',
            data: [
                {x: new Date(startX), y: startY},
                {x: new Date(endX), y: endY}
            ],
            borderColor: 'rgba(255, 99, 132, 0.8)',
            borderWidth: 3,
            pointRadius: 0,
            pointHoverRadius: 0,
            fill: false,
            tension: 0,
            order: 3  // Will be rendered on top
        });
    }

    // Create a minimal chart
    combinedChartObj = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,  // Allow chart to fill container
            animation: false,
            animations: {
                colors: false,
                x: false,
                y: false
            },
            transitions: {
                active: {
                    animation: {
                        duration: 0
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    position: 'bottom',
                    time: {
                        unit: 'day',
                        displayFormats: {
                            day: 'yyyy-MM-dd'
                        }
                    },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45,
                        // Limit the number of ticks to reduce processing
                        maxTicksLimit: 10
                    },
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Combined Score'
                    },
                    suggestedMax: Math.max(...combinedScoresSorted.map(parseFloat)) * 1.1,
                    // Set a fixed number of ticks to prevent auto-scaling issues
                    ticks: {
                        maxTicksLimit: 6
                    }
                }
            },            plugins: {
                // Very simple legend
                legend: {
                    display: true,
                    position: 'top',
                },
                tooltip: {
                    callbacks: {
                        title: function(tooltipItems) {
                            // Show date in tooltip title
                            const item = tooltipItems[0];
                            // Format the date to YYYY-MM-DD
                            const date = item.raw.originalDate ||
                                new Date(item.raw.x).toISOString().split('T')[0];
                            return `Date: ${date}`;
                        },
                        label: function(context) {
                            const dateObj = context.raw.x;
                            // Handle trend line points that don't have originalDate
                            if (!context.raw.originalDate && !dateObj) {
                                return ["Trend Line"];
                            }

                            const formattedDate = context.raw.originalDate ||
                                new Date(dateObj).toISOString().split('T')[0];

                            // Safely handle case when data might be missing
                            const data = originalDataByDate[formattedDate];
                            if (!data) {
                                return ["No data available"];
                            }

                            return [
                                `Combined Score: ${data.combinedScore}`,
                                `Score: ${data.score}/${data.maxScore} (${data.scorePercent}%)`,
                                `Time Bonus: ${data.timeBonus} (${data.timeRemaining}s/${data.maxTime}s)`
                            ];
                        }
                    }
                }
            }
        }
    });
}

});

</script>

{% endblock %}
