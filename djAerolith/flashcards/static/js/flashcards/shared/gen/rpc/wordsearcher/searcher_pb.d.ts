// @generated by protoc-gen-es v1.10.0
// @generated from file rpc/wordsearcher/searcher.proto (package wordsearcher, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * An Alphagram encapsulates info about an alphagram, including the words,
 * length, probability, combinations.
 *
 * @generated from message wordsearcher.Alphagram
 */
export declare class Alphagram extends Message<Alphagram> {
  /**
   * @generated from field: string alphagram = 1;
   */
  alphagram: string;

  /**
   * @generated from field: repeated wordsearcher.Word words = 2;
   */
  words: Word[];

  /**
   * expandedRepr is true if the length, probability, combinations are
   * included. Otherwise, this is an "unexpanded" alphagram.
   * Note that if expandedRepr is true, then the `words` field is also
   * expanded (with definition, hooks, etc).
   *
   * @generated from field: bool expandedRepr = 3;
   */
  expandedRepr: boolean;

  /**
   * @generated from field: int32 length = 4;
   */
  length: number;

  /**
   * @generated from field: int32 probability = 5;
   */
  probability: number;

  /**
   * @generated from field: int64 combinations = 6;
   */
  combinations: bigint;

  /**
   * @generated from field: int32 difficulty = 7;
   */
  difficulty: number;

  constructor(data?: PartialMessage<Alphagram>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.Alphagram";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Alphagram;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Alphagram;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Alphagram;

  static equals(a: Alphagram | PlainMessage<Alphagram> | undefined, b: Alphagram | PlainMessage<Alphagram> | undefined): boolean;
}

/**
 * A Word is more than just the string representing the word. It has other
 * info like the definition, hooks, lex symbols, etc.
 *
 * @generated from message wordsearcher.Word
 */
export declare class Word extends Message<Word> {
  /**
   * @generated from field: string word = 1;
   */
  word: string;

  /**
   * Note that this alphagram is not the same as Alphagram above.
   *
   * @generated from field: string alphagram = 2;
   */
  alphagram: string;

  /**
   * Note: the following fields are not filled in if the alphagram's
   * `expandedRepr` is false. Protobuf fields are optional already, but
   * this lets us be explicit.
   *
   * @generated from field: string definition = 3;
   */
  definition: string;

  /**
   * @generated from field: string front_hooks = 4;
   */
  frontHooks: string;

  /**
   * @generated from field: string back_hooks = 5;
   */
  backHooks: string;

  /**
   * @generated from field: string lexicon_symbols = 6;
   */
  lexiconSymbols: string;

  /**
   * @generated from field: bool inner_front_hook = 7;
   */
  innerFrontHook: boolean;

  /**
   * @generated from field: bool inner_back_hook = 8;
   */
  innerBackHook: boolean;

  constructor(data?: PartialMessage<Word>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.Word";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Word;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Word;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Word;

  static equals(a: Word | PlainMessage<Word> | undefined, b: Word | PlainMessage<Word> | undefined): boolean;
}

/**
 * A SearchRequest encapsulates a number of varied conditions and lets one
 * search for questions.
 *
 * @generated from message wordsearcher.SearchRequest
 */
export declare class SearchRequest extends Message<SearchRequest> {
  /**
   * @generated from field: repeated wordsearcher.SearchRequest.SearchParam searchparams = 1;
   */
  searchparams: SearchRequest_SearchParam[];

  /**
   * @generated from field: bool expand = 2;
   */
  expand: boolean;

  constructor(data?: PartialMessage<SearchRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest;

  static equals(a: SearchRequest | PlainMessage<SearchRequest> | undefined, b: SearchRequest | PlainMessage<SearchRequest> | undefined): boolean;
}

/**
 * @generated from enum wordsearcher.SearchRequest.Condition
 */
export declare enum SearchRequest_Condition {
  /**
   * @generated from enum value: LEXICON = 0;
   */
  LEXICON = 0,

  /**
   * @generated from enum value: LENGTH = 1;
   */
  LENGTH = 1,

  /**
   * @generated from enum value: PROBABILITY_RANGE = 2;
   */
  PROBABILITY_RANGE = 2,

  /**
   * @generated from enum value: PROBABILITY_LIST = 3;
   */
  PROBABILITY_LIST = 3,

  /**
   * @generated from enum value: PROBABILITY_LIMIT = 4;
   */
  PROBABILITY_LIMIT = 4,

  /**
   * @generated from enum value: NUMBER_OF_ANAGRAMS = 5;
   */
  NUMBER_OF_ANAGRAMS = 5,

  /**
   * @generated from enum value: NUMBER_OF_VOWELS = 6;
   */
  NUMBER_OF_VOWELS = 6,

  /**
   * TAGS won't be implemented in the server, but we still want
   * to define it here because the GUI client will use it (and
   * undergo transformation into ALPHAGRAM_LIST before it hits
   * the server)
   *
   * @generated from enum value: HAS_TAGS = 7;
   */
  HAS_TAGS = 7,

  /**
   * @generated from enum value: POINT_VALUE = 8;
   */
  POINT_VALUE = 8,

  /**
   * @generated from enum value: MATCHING_ANAGRAM = 9;
   */
  MATCHING_ANAGRAM = 9,

  /**
   * @generated from enum value: ALPHAGRAM_LIST = 10;
   */
  ALPHAGRAM_LIST = 10,

  /**
   * @generated from enum value: NOT_IN_LEXICON = 11;
   */
  NOT_IN_LEXICON = 11,

  /**
   * @generated from enum value: UPLOADED_WORD_OR_ALPHAGRAM_LIST = 12;
   */
  UPLOADED_WORD_OR_ALPHAGRAM_LIST = 12,

  /**
   * @generated from enum value: WORD_LIST = 13;
   */
  WORD_LIST = 13,

  /**
   * These are reserved for blank challenges. They're not even actually
   * used by this proto, but by the front end when displaying search
   * boxes.
   *
   * @generated from enum value: SINGLE_VALUE_LENGTH = 14;
   */
  SINGLE_VALUE_LENGTH = 14,

  /**
   * @generated from enum value: NUM_TWO_BLANKS = 15;
   */
  NUM_TWO_BLANKS = 15,

  /**
   * @generated from enum value: MAX_SOLUTIONS = 16;
   */
  MAX_SOLUTIONS = 16,

  /**
   * More alphagram searches
   *
   * @generated from enum value: DIFFICULTY_RANGE = 17;
   */
  DIFFICULTY_RANGE = 17,

  /**
   * @generated from enum value: PLAYABILITY_RANGE = 18;
   */
  PLAYABILITY_RANGE = 18,

  /**
   * @generated from enum value: DELETED_WORD = 19;
   */
  DELETED_WORD = 19,

  /**
   * Word-level searches (return alphagrams containing matching words)
   *
   * @generated from enum value: CONTAINS_HOOKS = 20;
   */
  CONTAINS_HOOKS = 20,

  /**
   * @generated from enum value: DEFINITION_CONTAINS = 21;
   */
  DEFINITION_CONTAINS = 21,
}

/**
 * @generated from enum wordsearcher.SearchRequest.NotInLexCondition
 */
export declare enum SearchRequest_NotInLexCondition {
  /**
   * @generated from enum value: OTHER_ENGLISH = 0;
   */
  OTHER_ENGLISH = 0,

  /**
   * @generated from enum value: PREVIOUS_VERSION = 1;
   */
  PREVIOUS_VERSION = 1,
}

/**
 * @generated from enum wordsearcher.SearchRequest.HookType
 */
export declare enum SearchRequest_HookType {
  /**
   * @generated from enum value: FRONT_HOOKS = 0;
   */
  FRONT_HOOKS = 0,

  /**
   * @generated from enum value: BACK_HOOKS = 1;
   */
  BACK_HOOKS = 1,

  /**
   * @generated from enum value: INNER_HOOKS = 2;
   */
  INNER_HOOKS = 2,
}

/**
 * @generated from message wordsearcher.SearchRequest.MinMax
 */
export declare class SearchRequest_MinMax extends Message<SearchRequest_MinMax> {
  /**
   * Used for length, prob range, prob limit, num anagrams,
   * num_vowels, point value
   *
   * @generated from field: int32 min = 1;
   */
  min: number;

  /**
   * @generated from field: int32 max = 2;
   */
  max: number;

  constructor(data?: PartialMessage<SearchRequest_MinMax>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchRequest.MinMax";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest_MinMax;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest_MinMax;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest_MinMax;

  static equals(a: SearchRequest_MinMax | PlainMessage<SearchRequest_MinMax> | undefined, b: SearchRequest_MinMax | PlainMessage<SearchRequest_MinMax> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.SearchRequest.StringValue
 */
export declare class SearchRequest_StringValue extends Message<SearchRequest_StringValue> {
  /**
   * Used for lexicon, matching anagram, not_in_lexicon
   *
   * @generated from field: string value = 1;
   */
  value: string;

  constructor(data?: PartialMessage<SearchRequest_StringValue>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchRequest.StringValue";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest_StringValue;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest_StringValue;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest_StringValue;

  static equals(a: SearchRequest_StringValue | PlainMessage<SearchRequest_StringValue> | undefined, b: SearchRequest_StringValue | PlainMessage<SearchRequest_StringValue> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.SearchRequest.StringArray
 */
export declare class SearchRequest_StringArray extends Message<SearchRequest_StringArray> {
  /**
   * Used for alphagram_list
   *
   * @generated from field: repeated string values = 1;
   */
  values: string[];

  constructor(data?: PartialMessage<SearchRequest_StringArray>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchRequest.StringArray";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest_StringArray;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest_StringArray;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest_StringArray;

  static equals(a: SearchRequest_StringArray | PlainMessage<SearchRequest_StringArray> | undefined, b: SearchRequest_StringArray | PlainMessage<SearchRequest_StringArray> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.SearchRequest.NumberArray
 */
export declare class SearchRequest_NumberArray extends Message<SearchRequest_NumberArray> {
  /**
   * Used for prob list
   *
   * @generated from field: repeated int32 values = 1;
   */
  values: number[];

  constructor(data?: PartialMessage<SearchRequest_NumberArray>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchRequest.NumberArray";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest_NumberArray;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest_NumberArray;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest_NumberArray;

  static equals(a: SearchRequest_NumberArray | PlainMessage<SearchRequest_NumberArray> | undefined, b: SearchRequest_NumberArray | PlainMessage<SearchRequest_NumberArray> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.SearchRequest.NumberValue
 */
export declare class SearchRequest_NumberValue extends Message<SearchRequest_NumberValue> {
  /**
   * @generated from field: int32 value = 1;
   */
  value: number;

  constructor(data?: PartialMessage<SearchRequest_NumberValue>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchRequest.NumberValue";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest_NumberValue;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest_NumberValue;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest_NumberValue;

  static equals(a: SearchRequest_NumberValue | PlainMessage<SearchRequest_NumberValue> | undefined, b: SearchRequest_NumberValue | PlainMessage<SearchRequest_NumberValue> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.SearchRequest.HooksParam
 */
export declare class SearchRequest_HooksParam extends Message<SearchRequest_HooksParam> {
  /**
   * @generated from field: wordsearcher.SearchRequest.HookType hook_type = 1;
   */
  hookType: SearchRequest_HookType;

  /**
   * @generated from field: string hooks = 2;
   */
  hooks: string;

  /**
   * if true, search for words that do NOT contain these hooks
   *
   * @generated from field: bool not_condition = 3;
   */
  notCondition: boolean;

  constructor(data?: PartialMessage<SearchRequest_HooksParam>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchRequest.HooksParam";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest_HooksParam;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest_HooksParam;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest_HooksParam;

  static equals(a: SearchRequest_HooksParam | PlainMessage<SearchRequest_HooksParam> | undefined, b: SearchRequest_HooksParam | PlainMessage<SearchRequest_HooksParam> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.SearchRequest.SearchParam
 */
export declare class SearchRequest_SearchParam extends Message<SearchRequest_SearchParam> {
  /**
   * @generated from field: wordsearcher.SearchRequest.Condition condition = 1;
   */
  condition: SearchRequest_Condition;

  /**
   * @generated from oneof wordsearcher.SearchRequest.SearchParam.conditionparam
   */
  conditionparam: {
    /**
     * @generated from field: wordsearcher.SearchRequest.MinMax minmax = 2;
     */
    value: SearchRequest_MinMax;
    case: "minmax";
  } | {
    /**
     * @generated from field: wordsearcher.SearchRequest.StringValue stringvalue = 3;
     */
    value: SearchRequest_StringValue;
    case: "stringvalue";
  } | {
    /**
     * @generated from field: wordsearcher.SearchRequest.StringArray stringarray = 4;
     */
    value: SearchRequest_StringArray;
    case: "stringarray";
  } | {
    /**
     * @generated from field: wordsearcher.SearchRequest.NumberArray numberarray = 5;
     */
    value: SearchRequest_NumberArray;
    case: "numberarray";
  } | {
    /**
     * @generated from field: wordsearcher.SearchRequest.NumberValue numbervalue = 6;
     */
    value: SearchRequest_NumberValue;
    case: "numbervalue";
  } | {
    /**
     * @generated from field: wordsearcher.SearchRequest.HooksParam hooksparam = 7;
     */
    value: SearchRequest_HooksParam;
    case: "hooksparam";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<SearchRequest_SearchParam>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchRequest.SearchParam";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest_SearchParam;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest_SearchParam;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest_SearchParam;

  static equals(a: SearchRequest_SearchParam | PlainMessage<SearchRequest_SearchParam> | undefined, b: SearchRequest_SearchParam | PlainMessage<SearchRequest_SearchParam> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.SearchResponse
 */
export declare class SearchResponse extends Message<SearchResponse> {
  /**
   * @generated from field: repeated wordsearcher.Alphagram alphagrams = 1;
   */
  alphagrams: Alphagram[];

  /**
   * @generated from field: string lexicon = 2;
   */
  lexicon: string;

  constructor(data?: PartialMessage<SearchResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.SearchResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse;

  static equals(a: SearchResponse | PlainMessage<SearchResponse> | undefined, b: SearchResponse | PlainMessage<SearchResponse> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.AnagramRequest
 */
export declare class AnagramRequest extends Message<AnagramRequest> {
  /**
   * @generated from field: string lexicon = 1;
   */
  lexicon: string;

  /**
   * @generated from field: string letters = 2;
   */
  letters: string;

  /**
   * @generated from field: wordsearcher.AnagramRequest.Mode mode = 3;
   */
  mode: AnagramRequest_Mode;

  /**
   * Whether to provide hooks, defos, ec.
   *
   * @generated from field: bool expand = 4;
   */
  expand: boolean;

  constructor(data?: PartialMessage<AnagramRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.AnagramRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnagramRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnagramRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnagramRequest;

  static equals(a: AnagramRequest | PlainMessage<AnagramRequest> | undefined, b: AnagramRequest | PlainMessage<AnagramRequest> | undefined): boolean;
}

/**
 * @generated from enum wordsearcher.AnagramRequest.Mode
 */
export declare enum AnagramRequest_Mode {
  /**
   * @generated from enum value: EXACT = 0;
   */
  EXACT = 0,

  /**
   * @generated from enum value: BUILD = 1;
   */
  BUILD = 1,

  /**
   * *
   *
   * @generated from enum value: SUPER = 2;
   */
  SUPER = 2,
}

/**
 * @generated from message wordsearcher.AnagramResponse
 */
export declare class AnagramResponse extends Message<AnagramResponse> {
  /**
   * @generated from field: repeated wordsearcher.Word words = 1;
   */
  words: Word[];

  /**
   * @generated from field: int32 num_words = 2;
   */
  numWords: number;

  constructor(data?: PartialMessage<AnagramResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.AnagramResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnagramResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnagramResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnagramResponse;

  static equals(a: AnagramResponse | PlainMessage<AnagramResponse> | undefined, b: AnagramResponse | PlainMessage<AnagramResponse> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.BlankChallengeCreateRequest
 */
export declare class BlankChallengeCreateRequest extends Message<BlankChallengeCreateRequest> {
  /**
   * @generated from field: string lexicon = 1;
   */
  lexicon: string;

  /**
   * The number of questions to generate.
   *
   * @generated from field: int32 num_questions = 2;
   */
  numQuestions: number;

  /**
   * The max number of solutions per question.
   *
   * @generated from field: int32 max_solutions = 3;
   */
  maxSolutions: number;

  /**
   * The number of questions with two blanks.
   *
   * @generated from field: int32 num_with_2_blanks = 4;
   */
  numWith2Blanks: number;

  /**
   * @generated from field: int32 word_length = 5;
   */
  wordLength: number;

  constructor(data?: PartialMessage<BlankChallengeCreateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.BlankChallengeCreateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlankChallengeCreateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlankChallengeCreateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlankChallengeCreateRequest;

  static equals(a: BlankChallengeCreateRequest | PlainMessage<BlankChallengeCreateRequest> | undefined, b: BlankChallengeCreateRequest | PlainMessage<BlankChallengeCreateRequest> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.BuildChallengeCreateRequest
 */
export declare class BuildChallengeCreateRequest extends Message<BuildChallengeCreateRequest> {
  /**
   * @generated from field: string lexicon = 1;
   */
  lexicon: string;

  /**
   * @generated from field: int32 min_solutions = 2;
   */
  minSolutions: number;

  /**
   * @generated from field: int32 max_solutions = 3;
   */
  maxSolutions: number;

  /**
   * @generated from field: int32 min_length = 4;
   */
  minLength: number;

  /**
   * @generated from field: int32 max_length = 5;
   */
  maxLength: number;

  /**
   * Whether a solution for the given word length is required
   *
   * @generated from field: bool require_length_solution = 6;
   */
  requireLengthSolution: boolean;

  constructor(data?: PartialMessage<BuildChallengeCreateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.BuildChallengeCreateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildChallengeCreateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildChallengeCreateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildChallengeCreateRequest;

  static equals(a: BuildChallengeCreateRequest | PlainMessage<BuildChallengeCreateRequest> | undefined, b: BuildChallengeCreateRequest | PlainMessage<BuildChallengeCreateRequest> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.WordSearchRequest
 */
export declare class WordSearchRequest extends Message<WordSearchRequest> {
  /**
   * @generated from field: string lexicon = 1;
   */
  lexicon: string;

  /**
   * the only acceptable glob characters are * and ?. These get mapped
   * to SQLITE % and _, respectively.
   *
   * @generated from field: string glob = 2;
   */
  glob: string;

  /**
   * Which field the glob applies to (word or definition?)
   *
   * @generated from field: string applies_to = 3;
   */
  appliesTo: string;

  constructor(data?: PartialMessage<WordSearchRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.WordSearchRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WordSearchRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WordSearchRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WordSearchRequest;

  static equals(a: WordSearchRequest | PlainMessage<WordSearchRequest> | undefined, b: WordSearchRequest | PlainMessage<WordSearchRequest> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.DefineRequest
 */
export declare class DefineRequest extends Message<DefineRequest> {
  /**
   * @generated from field: string lexicon = 1;
   */
  lexicon: string;

  /**
   * @generated from field: string word = 2;
   */
  word: string;

  constructor(data?: PartialMessage<DefineRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.DefineRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DefineRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DefineRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DefineRequest;

  static equals(a: DefineRequest | PlainMessage<DefineRequest> | undefined, b: DefineRequest | PlainMessage<DefineRequest> | undefined): boolean;
}

/**
 * @generated from message wordsearcher.WordSearchResponse
 */
export declare class WordSearchResponse extends Message<WordSearchResponse> {
  /**
   * @generated from field: repeated wordsearcher.Word words = 1;
   */
  words: Word[];

  constructor(data?: PartialMessage<WordSearchResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "wordsearcher.WordSearchResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WordSearchResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WordSearchResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WordSearchResponse;

  static equals(a: WordSearchResponse | PlainMessage<WordSearchResponse> | undefined, b: WordSearchResponse | PlainMessage<WordSearchResponse> | undefined): boolean;
}

